#include <iostream>
using namespace std;

#define delimiter "\n-----------------------------------------------------------------\n"

class Point
{
	// Создавая структуру или класс, мы создаем новый тип данных (пользовательский тип данных).
	// Пользовательские типы являются более сложными, поскольку могут включать в себя множество однотипных или разнотипных значений, которые являются характеристиками и состояниями объектов.
	double x;
	double y;
public:
	double get_x() const
	{
		return x;
	}
	double get_y() const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}

	//Constructors;
	/*Point()
	{
		x = y = 0;
		cout << "DefaultConstructor:\t" << this << endl;
	}
	*/

	/*Point(double x)
	{
		this->x = x;
		this->y = 0;
		cout << "SingleArgumentConstructor:\t" << this << endl;
		//Конструктор с одним параметром
	}*/

	Point(double x=0, double y=0)
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t\t" << this << endl;
	}

	Point(const Point& other)
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyConstructor:\t" << this << endl;
	}

	~Point()
	{
		cout << "Destructor:\t\t" << this << endl;
	}
	//Methods;

	double distance(Point other)
	{
		//this - эта точка (находим расстояние от этой точки)
		//other - та точка (до указанной точки)
		double x_distance = this->x - other.x;
		double y_distance = this->y - other.y;
		double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
		//sqrt() - квадратный корень
		return distance;
	}
	void print()const
	{
		cout << this << ": X = " << x << ",\tY = " << y << endl;
	}
};

double distance(Point A, Point B)
{
	double x_distance = A.get_x() - B.get_x();
	double y_distance = A.get_y() - B.get_y();
	double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
	return distance;
}

//#define STRUCT_POINT
#define DISTANCE_CHECK
//#define CONSTRUCTORS_CHECK

void main()
{
	setlocale(LC_ALL, "");
#ifdef STRUCT_POINT
	Point A; //Создание перемененой "A" типа "Point"
	//Создание объекта "A" структуры "Point"
	//Создание экземпляра "A" структуры "Point"
	A.x = 2;
	A.y = 3;
	cout << A.x << "\t" << A.y << endl;

	Point* pA = &A;
	cout << pA->x << "\t" << pA->y << endl;
#endif

#ifdef DISTANCE_CHECK
	Point A;
	A.set_x(2);
	A.set_y(3);
	cout << A.get_x() << "\t" << A.get_y() << endl;

	Point B;
	B.set_x(7);
	B.set_y(8);
	cout << B.get_x() << "\t" << B.get_y() << endl;
	cout << delimiter << endl;
	cout << "Расстояние от точки 'А' до точки 'B': " << A.distance(B) << endl;
	cout << delimiter << endl;
	cout << "Расстояние от точки 'B' до точки 'A': " << B.distance(A) << endl;
	cout << delimiter << endl;
	cout << "Расстояние между точками 'A' и 'B': " << distance(A, B) << endl;
	cout << delimiter << endl;
	cout << "Расстояние между точками 'B' и 'A': " << distance(B, A) << endl;
#endif

	//for (int i = 0; i < 10; i++)
	//{
	//	cout << i << "\t";
    //}
	//cout << endl;

#ifdef CONSTRUCTORS_CHECK
	Point A;
	A.print();
	//{
		//Point A;
	//	Point B;
	//	cout << "Point B существует" << endl;
	//	B.distance(A);
	//}
//	cout << "Здесь Point B уже НЕ существует" << endl;

	Point B = 5; //Параметризованный конструктор позволяет нам объявить, каким будет наш объект при создании
	B.print();

	Point C(7, 8);
	C.print();

	Point D = C;
	D.print();
#endif
}


/*
Объектно-ориентированное программирование на языке C++:

1) Введение в ООП:

Объектно-ориентированное программирование (ООП) - это подход при котором программа строится из объектов.
Объект - это некая сущность, которая существует в пространстве и времени.

Объекты могут существовать в объективной, субъективной или виртуальной реальности. ООП позволяет спроецировать объекты из объективной и субъективной реальности в виртуальную.

Абсолютно все объекты обладают некими характеристиками, состояниями и поведениями.

Объекты принято классифицировать. Класс - это множество объектов с одинаковым набором характеристик, состояний и поведений.

С точки зрения ООП, класс - это синтаксическая конструкция, позволяющая описывать объекты.
Классы состоят из полей или членов.
Поля или члены класса бывают двух видов:
1) Переменные
2) Методы

Классы часто изображают UML (Unified Modeling Language) диаграммами:

Data - переменные члены класса (Member - variables) - описывают характеристики объектов, и их состояния.
Methods - определяют поведение объектов, и их взаимодействие с другими объектами. Методы еще называют member-functions (функции-члены класса).

Метод - это функция внутри класса. Метод может быть вызван только для какого-то объекта.

Кроме классов, объекты так же можно описывать при помощи структур. Структура - это такая же синтаксическая конструкция, позволяющая описывать объекты.

Структура - это тип данных
Класс - это тип данных
-------------------------------------------------------------------------
Для доступа к полям объектов используются два оператора:

. - Оператор прямого доступа (Point operator). Предназначен для доступа к полям объекта по имени объекта.
-> - Оператор косвенного доступа (Arrow operator). Предназначен для доступа к полям объекта по адресу объекта.
-------------------------------------------------------------------------
Концепции ООП:

ООП базируется на трех основных концепциях:
1) Инкапсуляция (Encapsulation)
2) Наследование (Inheritance)
3) Полиморфизм (Polymorphism)

Инкапсуляция - это сокрытие определенной части класса от внешнего мира. Инкапсуляция реализуется модификаторами доступа и get/set методами
В C++ существует всего 3 модификатора доступа:
1) Private:                  закрытые поля, доступные только внутри класса (member-variables)
2) Public:                   открытые поля, доступные из любого места программы (member-functions)
3) Protected:                защищенные поля, доступные только внутри класса и его дочерних классов

Переменные члены класса должны быть в private секции, переменные обязательно должны быть закрытыми.
Размещение переменных в pubic секции - грубейшее нарушение инкапсуляции.

В public секции, как правило, располагают методы (method functions). Методы могут быть расположены и в private секции.

Единственное отличие между классом и структурой заключается в том, что у структуры все поля открыты, если не указано обратное, а у класса все поля закрыты, если не указано обратное.
-------------------------------------------------------------------------
Get/set - методы
Get (Взять, получить) - эти методы открывают доступ к переменным членам класса на чтение, то есть позволяют получить значение переменной в классе.
Get-методы обязательно должны быть константными.
Константным называется метод, который не вызывает объект, для которого вызывается.
Для константного объекта могут быть вызваны только константные методы

Set (Задать, установить) - эти методы открывают доступ к переменным членам класса на запись, то есть позволяют задавать значение закрытых переменных.
Кроме того, set-методы обеспечивают фильтрацию данных, то есть предотвращают попадание некорректных значений в переменные члены класса.

Абсолютно у каждой переменной в классе должен быть свой get метод и set метод.

This - это указатель на объект, для которого вызывается метод.
Изнутри объекта никогда нельзя узнать его имя, но всегда можно узнать его адрес при помощи this.

----------------------------------------------------------------------
Особые методы в классе:

В любом классе должно бытьк как минимум 3 особых метода:
1) Constructor;
2) Destructor;
3) Assignment operator;

Constructor - это метод, который создает объект, а именно, выделяет память под объект и инициализирует его поля.
Destructor - это метод, который уничтожает объект по истечении его времени жизни.

Constructor и destructor всегда называется как класс, но перед destructor всегда ставится "~".
Constructor и destructor никогда не возращают никаких значений, и при этом перед ними даже не пишется void.

Constructor, как и любая другая функция, может принимать параметры. Следовательно, как и любую другую функцию, его можно перегрузить. 
Именно поэтому, в классе может быть сколько угодно конструкторов

Destructor не принимает никаких параметров и перегрузить его нельзя. Именно поэтому в классе может быть только один destructor.
Другими словами, объекты могут создаваться по разному и разными способами, но независимо от того, каким образом создан объект, все объекты удаляются одинаково.

Constructor бывает:
1) С параметрами
2) Без параметров
3) По умолчанию
4) Конструктор копирования
5) Конструктор переноса

Конструктор по умолчанию - это конструктор, который может быть вызван без параметров, конструктор не принимающий никаких параметров, а так же принимающий параметры по умолчанию.
Конструктор по умолчанию всякий раз неявно вызывается, когда мы просто создаем объект и не знаем каким он будет. В таком случае, создается объект по умолчанию.
И каждое поле такого объекта, должно хранить значение по умолчанию
Конструктор по умолчанию может быть неявным, и если программист не написал ни единого конструктора в классе, то компилятор сам неявно добавит туда конструктор по умолчанию
поскольку без конструктора невозможно создать объект. Такой неявный конструктор по умолчанию просто выделяет память под объект и заполняет его поля мусором.
Если в классе написать хотя бы один конструктор, то неявный конструктор по умолчанию сразу удаляется

Конструктор копирования - это конструктор, который копирует объект, а именно делает создаваемый объект точной копией другого создаваемого объекта.
Конструктор копирование всегда принимает константную ссылку на объект. 
Объекты могут копироваться явным образом: "Point D=C" и неявным, при передаче объекта в функцию по значению.

Время жизни объекта истекает при выходе за пределы области видимости, в которой он объявлен. Это может быть функция, if, цикл и любые фигурные скобки.
Поскольку фигурные скобки порождают область видимости и простанства имен.
*/